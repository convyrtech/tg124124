# План исправления проблем миграции

**Дата:** 2026-02-03
**Статус:** В разработке

---

## Приоритеты

| Приоритет | Описание |
|-----------|----------|
| P0 | КРИТИЧЕСКИЙ - блокирует работу, исправить первым |
| P1 | ВЫСОКИЙ - серьёзно влияет на надёжность |
| P2 | СРЕДНИЙ - улучшает стабильность |
| P3 | НИЗКИЙ - nice to have |

---

## PHASE 1: Критические исправления (P0)

### FIX-001: QR decode grey zone
**Файл:** `src/telegram_auth.py:757`
**Проблема:** Проверка `if len(result) < 500` неправильно определяет token vs screenshot
**Влияние:** QR никогда не декодируется в некоторых случаях

**Решение:**
```python
# БЫЛО:
if len(result) < 500:
    return result  # Already a token
# ... decode as screenshot

# СТАЛО:
def _is_valid_token(data: bytes) -> bool:
    """Проверяет является ли data валидным QR token."""
    try:
        text = data.decode('utf-8')
        # Telegram QR tokens начинаются с tg://login?token=
        if text.startswith('tg://login?token='):
            token = text.split('token=')[1].split('&')[0]
            return len(token) >= 20
        return False
    except:
        return False

# В _extract_qr_token:
if _is_valid_token(result):
    return extract_token_from_tg_url(result.decode('utf-8'))
# ... decode as screenshot
```

**Тест:** Миграция аккаунта должна успешно декодировать QR

---

### FIX-002: SQLite WAL mode для session
**Файл:** `src/telegram_auth.py:439-461`
**Проблема:** "database is locked" при параллельной работе
**Влияние:** Batch миграция падает

**Решение:**
```python
async def _create_telethon_client(self) -> TelegramClient:
    # Включить WAL режим для SQLite session
    session_path = self.account.session_path
    if session_path.exists():
        import sqlite3
        try:
            conn = sqlite3.connect(str(session_path), timeout=10)
            conn.execute('PRAGMA journal_mode=WAL')
            conn.execute('PRAGMA busy_timeout=10000')  # 10 секунд ожидания при блокировке
            conn.close()
        except sqlite3.Error as e:
            logger.warning(f"Could not set WAL mode: {e}")

    # ... остальной код создания клиента
```

**Тест:** Запустить 2 миграции одновременно, не должно быть "database is locked"

---

### FIX-003: Удаление browser lock файлов
**Файл:** `src/browser_manager.py:176-234`
**Проблема:** После краша остаются lock файлы, браузер не запускается
**Влияние:** "Target page closed" ошибка

**Решение:**
```python
async def launch(self, profile: BrowserProfile, headless: bool = False, extra_args: Optional[Dict] = None) -> BrowserContext:
    # Очистка lock файлов от предыдущего краша
    browser_data_path = profile.browser_data_path
    if browser_data_path.exists():
        lock_patterns = ['*.lock', 'parent.lock', '.parentlock', 'lock']
        for pattern in lock_patterns:
            for lock_file in browser_data_path.glob(pattern):
                try:
                    lock_file.unlink()
                    logger.debug(f"Removed stale lock file: {lock_file}")
                except Exception as e:
                    logger.warning(f"Could not remove lock file {lock_file}: {e}")

    # ... остальной код launch
```

**Тест:** Убить браузер через Task Manager, запустить снова - должен запуститься

---

### FIX-004: File lock для migration state
**Файл:** `src/migration_state.py:83-92`
**Проблема:** Race condition при параллельной записи в JSON
**Влияние:** Потеря данных о статусе миграции

**Решение:**
```python
import os
import sys

if sys.platform == 'win32':
    import msvcrt
    def _lock_file(f):
        msvcrt.locking(f.fileno(), msvcrt.LK_LOCK, 1)
    def _unlock_file(f):
        msvcrt.locking(f.fileno(), msvcrt.LK_UNLCK, 1)
else:
    import fcntl
    def _lock_file(f):
        fcntl.flock(f, fcntl.LOCK_EX)
    def _unlock_file(f):
        fcntl.flock(f, fcntl.LOCK_UN)

def _save(self) -> None:
    if self._state is None:
        return

    # Atomic write with file lock
    temp_file = self.state_file.with_suffix('.tmp')
    with open(temp_file, 'w', encoding='utf-8') as f:
        _lock_file(f)
        try:
            data = asdict(self._state)
            f.write(json.dumps(data, indent=2, ensure_ascii=False))
        finally:
            _unlock_file(f)

    # Atomic rename
    temp_file.replace(self.state_file)
```

**Тест:** Запустить 5 параллельных миграций, state файл не должен быть повреждён

---

## PHASE 2: Высокоприоритетные исправления (P1)

### FIX-005: 2FA селектор и visibility
**Файл:** `src/telegram_auth.py:879-926`
**Проблема:** Селектор hardcoded, не проверяется visibility
**Влияние:** 2FA пароль не вводится автоматически

**Решение:**
```python
async def _handle_2fa(self, page, password: str) -> bool:
    """Вводит 2FA пароль."""
    logger.info("Entering 2FA password...")

    # Расширенный список селекторов
    password_selectors = [
        'input[type="password"].input-field-input',
        'input[name="notsearch_password"]',
        'input[type="password"]:not([style*="display: none"])',
        '.input-field-input[type="password"]',
        'input[placeholder="Password"]',
        'input[placeholder*="assword"]',
        'input[autocomplete="current-password"]',
        # Telegram Web A селекторы
        'input.PasswordForm__input',
        'input[data-test="password-input"]',
    ]

    found_selector = None
    password_input = None

    for attempt in range(15):  # Увеличено с 10 до 15
        for selector in password_selectors:
            try:
                element = await page.query_selector(selector)
                if element:
                    # Проверяем НЕСКОЛЬКО критериев видимости
                    is_visible = await element.is_visible()
                    is_enabled = await element.is_enabled()
                    box = await element.bounding_box()

                    if is_visible and is_enabled and box and box['width'] > 0:
                        password_input = element
                        found_selector = selector
                        logger.debug(f"Found password input: {selector}")
                        break
            except Exception:
                continue

        if password_input:
            break
        await asyncio.sleep(1)

    if not password_input:
        # Debug screenshot
        debug_path = Path("profiles") / f"debug_2fa_{datetime.now().strftime('%H%M%S')}.png"
        await page.screenshot(path=str(debug_path))
        logger.error(f"Password input not found! Screenshot: {debug_path}")
        return False

    try:
        # Используем НАЙДЕННЫЙ селектор, не hardcoded
        await page.click(found_selector, timeout=5000)
        await asyncio.sleep(0.3)

        # Ввод пароля с умеренной скоростью
        await page.keyboard.type(password, delay=50)
        await asyncio.sleep(0.5)

        # Submit
        await page.keyboard.press('Enter')
        logger.info("Password submitted, waiting for response...")

        # Ждём результата
        await asyncio.sleep(3)
        return True

    except Exception as e:
        logger.error(f"Error entering 2FA: {e}")
        return False
```

**Тест:** Миграция аккаунта с 2FA должна пройти без ручного ввода

---

### FIX-006: Timeout для Telethon connect
**Файл:** `src/telegram_auth.py:451`
**Проблема:** connect() может зависнуть навечно
**Влияние:** Миграция зависает

**Решение:**
```python
async def _create_telethon_client(self) -> TelegramClient:
    # ... setup code ...

    try:
        await asyncio.wait_for(client.connect(), timeout=30)
    except asyncio.TimeoutError:
        raise RuntimeError("Telethon connect timeout after 30s")

    if not await client.is_user_authorized():
        await client.disconnect()
        raise RuntimeError("Session is not authorized. Cannot proceed with QR login.")

    return client
```

---

### FIX-007: Timeout для browser launch
**Файл:** `src/browser_manager.py:223-224`
**Проблема:** Запуск браузера может зависнуть (особенно при высокой нагрузке)
**Влияние:** Миграция зависает на 180 секунд

**Решение:**
```python
# В методе launch():
BROWSER_LAUNCH_TIMEOUT = 60  # секунд

try:
    browser = await asyncio.wait_for(
        camoufox.__aenter__(),
        timeout=BROWSER_LAUNCH_TIMEOUT
    )
except asyncio.TimeoutError:
    # Cleanup relay if started
    if proxy_relay:
        await proxy_relay.stop()
    raise RuntimeError(f"Browser launch timeout after {BROWSER_LAUNCH_TIMEOUT}s")
```

---

## PHASE 3: Среднеприоритетные исправления (P2)

### FIX-008: Увеличить QR retry до 5
**Файл:** `src/telegram_auth.py` константы
**Решение:** `QR_MAX_RETRIES = 5` вместо 3

---

### FIX-009: Сохранять debug screenshots с timestamp
**Файл:** `src/telegram_auth.py:771-775`
**Решение:**
```python
debug_path = Path("profiles") / f"debug_qr_{profile_name}_{datetime.now().strftime('%H%M%S')}_r{retry}.png"
```

---

### FIX-010: Timeout для canvas extraction
**Файл:** `src/telegram_auth.py:619-647`
**Решение:**
```python
try:
    qr_from_canvas = await asyncio.wait_for(
        page.evaluate("""..."""),
        timeout=5
    )
except asyncio.TimeoutError:
    logger.warning("Canvas extraction timeout")
    qr_from_canvas = None
```

---

### FIX-011: Health check для proxy relay
**Файл:** `src/proxy_relay.py:143-151`
**Решение:**
```python
async def start(self) -> str:
    # ... start process ...

    # Health check - verify relay is listening
    for _ in range(10):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            sock.connect((self.local_host, self.local_port))
            sock.close()
            logger.info(f"Proxy relay verified on {self.local_url}")
            return self.local_url
        except:
            await asyncio.sleep(0.5)

    raise RuntimeError(f"Proxy relay not responding on {self.local_url}")
```

---

### FIX-012: Правильное завершение batch
**Файл:** `src/cli.py` и `src/telegram_auth.py`
**Решение:** Явно вызывать `state.finish_batch()` в конце миграции

---

## PHASE 4: Улучшения UX (P3)

### FIX-013: Прогресс-бар для batch миграции
Добавить tqdm или rich progress bar

### FIX-014: Цветной вывод статусов
Зелёный = успех, Красный = ошибка, Жёлтый = предупреждение

### FIX-015: Авто-skip уже мигрированных
Если профиль существует и storage_state валидный - пропустить

---

## Порядок выполнения

```
PHASE 1 (Критические) - 2-3 часа
├── FIX-001: QR grey zone
├── FIX-002: SQLite WAL
├── FIX-003: Lock files cleanup
└── FIX-004: State file lock

PHASE 2 (Высокий приоритет) - 1-2 часа
├── FIX-005: 2FA selectors
├── FIX-006: Telethon timeout
└── FIX-007: Browser launch timeout

PHASE 3 (Средний приоритет) - 1 час
├── FIX-008: QR retries
├── FIX-009: Debug screenshots
├── FIX-010: Canvas timeout
├── FIX-011: Relay health check
└── FIX-012: Batch finish

PHASE 4 (UX) - опционально
├── FIX-013: Progress bar
├── FIX-014: Colored output
└── FIX-015: Skip migrated
```

---

## Верификация после исправлений

### Тест 1: Одиночная миграция
```bash
python -m src.cli migrate --account "Софт 317" --password "***" --headless
```
**Ожидание:** Успешная миграция за < 2 минут

### Тест 2: Batch миграция (3 аккаунта)
```bash
python -m src.cli migrate --all --password "***" --headless --cooldown 30
```
**Ожидание:** Все здоровые аккаунты мигрированы, state файл корректный

### Тест 3: Resume после прерывания
```bash
# Запустить и прервать через Ctrl+C
python -m src.cli migrate --all --headless
# Ctrl+C через 30 секунд

# Продолжить
python -m src.cli migrate --resume --headless
```
**Ожидание:** Продолжает с pending аккаунтов, completed не трогает

### Тест 4: Краш recovery
```bash
# Запустить миграцию
python -m src.cli migrate --account "Софт 313" --headless &
# Убить через Task Manager

# Запустить снова
python -m src.cli migrate --account "Софт 313" --headless
```
**Ожидание:** Браузер запускается несмотря на lock файлы

---

## Метрики успеха

| Метрика | Было | Цель |
|---------|------|------|
| Success rate одиночной миграции | ~50% | >95% |
| Success rate batch миграции | ~30% | >90% |
| Время одной миграции | 3-5 мин | <2 мин |
| QR decode success | ~60% | >98% |
| 2FA auto-input success | ~20% | >90% |
| Recovery после краша | 0% | 100% |
